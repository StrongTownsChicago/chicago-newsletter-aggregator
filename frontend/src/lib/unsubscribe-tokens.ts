/**
 * Token validation for unsubscribe functionality.
 *
 * Validates tokens generated by Python's itsdangerous library.
 * Must match the format and signing algorithm used in backend.
 */

import { createHmac, timingSafeEqual } from "node:crypto";

const SALT = "unsubscribe";

/**
 * Validates an unsubscribe token generated by Python's itsdangerous.
 *
 * Token format (from itsdangerous.URLSafeTimedSerializer):
 * base64(payload).base64(timestamp).base64(signature)
 *
 * @param token - Token string from URL parameter
 * @param secretKey - Secret key (must match Python's UNSUBSCRIBE_SECRET_KEY)
 * @param maxAgeSeconds - Maximum token age in seconds (default: 90 days)
 * @returns user_id if valid, null if invalid or expired
 */
export function validateUnsubscribeToken(
  token: string,
  secretKey: string,
  maxAgeSeconds: number = 90 * 24 * 60 * 60 // 90 days
): string | null {
  try {
    // Split token into parts
    const parts = token.split(".");
    if (parts.length !== 3) {
      return null;
    }

    const [payloadB64, timestampB64, signatureB64] = parts;

    // Decode payload and timestamp
    const payload = Buffer.from(payloadB64, "base64url").toString("utf-8");
    const timestampBytes = Buffer.from(timestampB64, "base64url");

    // Parse timestamp (big-endian unsigned 32-bit integer)
    const timestamp = timestampBytes.readUInt32BE(0);

    // Check expiry
    const currentTime = Math.floor(Date.now() / 1000);
    if (currentTime - timestamp > maxAgeSeconds) {
      return null; // Expired
    }

    // Verify signature
    const toSign = `${payloadB64}.${timestampB64}`;
    const expectedSig = signToken(toSign, secretKey);

    // Timing-safe comparison
    const providedSig = Buffer.from(signatureB64, "base64url");
    const expectedSigBuf = Buffer.from(expectedSig, "base64url");

    if (
      providedSig.length !== expectedSigBuf.length ||
      !timingSafeEqual(providedSig, expectedSigBuf)
    ) {
      return null; // Invalid signature
    }

    // Parse payload (JSON string from Python)
    const userId = JSON.parse(payload);

    return userId as string;
  } catch {
    // Any parsing error means invalid token
    return null;
  }
}

/**
 * Sign a message using HMAC-SHA256 (matches itsdangerous algorithm).
 */
function signToken(message: string, secretKey: string): string {
  // Derive key using same method as itsdangerous
  const derivedKey = deriveKey(secretKey, SALT);

  // Create HMAC signature
  const hmac = createHmac("sha256", derivedKey);
  hmac.update(message);
  const signature = hmac.digest();

  // Return base64url encoded signature
  return signature.toString("base64url");
}

/**
 * Derive key from secret and salt (matches itsdangerous key derivation).
 */
function deriveKey(secretKey: string, salt: string): Buffer {
  // itsdangerous uses simple HMAC-based key derivation
  const hmac = createHmac("sha256", Buffer.from(secretKey, "utf-8"));
  hmac.update(Buffer.from(salt, "utf-8"));
  return hmac.digest();
}
